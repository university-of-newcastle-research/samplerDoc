# PMwG sampler and Signal Detection Theory

Here we demonstrate how to use the PMwG sampler package to run a simple signal detection theory (SDT) analysis on data from a lexical decision task.  We recognise that it is unnecessary to use the sampler package for a simple analysis such as this; however, we hope this SDT example demonstrates the practicality of the PMwG sampler package.  

### Signal Detection Theory analysis of lexical decision task {#sdtOutline}

We won't cover SDT and lexical decision tasks in detail here; however, we will explain how you can use the PMwG package with SDT in the context of a lexical decision task. If you require more information, please visit the [SDT](https://en.wikipedia.org/wiki/Detection_theory) and [lexical decision task](https://en.wikipedia.org/wiki/Lexical_decision_task) Wikipedia pages. Also, this [Frontiers in Psychology](https://www.frontiersin.org/articles/10.3389/fpsyg.2015.00762/full) tutorial paper by @anderson2015teaching is another good resource for SDT.
<br> 

Participants were asked to indicate whether a letter string was a <i>word</i> or a <i>non-word</i>. We begin with the distributions for <i>non-word</i> and <i>word</i> stimuli. You can think of these two distributions as the 'noise' and 'signal' curves, respectively. Each distribution represents the evidence for 'word-likeness' and they are assumed to be normally distributed. The <i>non-word</i> distribution (or the 'noise' distribution) has a mean ($\mu$) of 0 and a standard deviation (SD) of 1. We could estimate SD here, but we will use 1 in this example for simplicity. The mean for the <i>word</i> distribution is unknown at this point; however, we assign a d-prime (d') parameter to denote the difference between the mean of the <i>non-word</i> and the mean of the <i>word</i> distributions (i.e. the 'sensitivity' to word stimuli or the signal-noise difference between <i>words</i> and <i>non-word</i>). As can be seen in Figure \@ref(fig:SDT1), the <i>word</i> distribution mean is greater than the <i>non-word</i> distribution mean; however, the distributions partially overlap where <i>non-words</i> and <i>words</i> are difficult to classify.
<br>
```{r SDT1, echo=FALSE, out.width='100%', fig.show='hold', fig.cap='Simple SDT example of lexical decision task'}
knitr::include_graphics('pngs/SDT_1.png')
```

The second parameter we denote is the criterion (<b>C</b>) parameter. The criterion is the point at which an individual responds <i>non-word</i> (to the left of <b>C</b> in Figure \@ref(fig:SDT2)) or <i>word</i> (to the right of <b>C</b> in Figure \@ref(fig:SDT2)) and it is set somewhere between the means of the two distributions. If you're biased to respond <i>word</i>, the criterion would move to the left. Conversely, if you're biased to respond <i>non-word</i> then the criterion would move to the right.

```{r SDT2, echo=FALSE, out.width='100%', fig.show='hold', fig.cap='Simple SDT example of lexical decision task'}
knitr::include_graphics('pngs/SDT_2.png')
```


### The log-likelihood function{#SDTLLFun}
#### What is a log-likelihood?{#WTFisaLLf}
The log-likelihood function is the ‘engine’ of the PMwG sampler. It is the way that the parameters of the model are connected to the data. In making this connection between data and parameters, the log-likelihood function actually defines the model and it's associated psychological theory. The function takes in data (for a single subject) parameter values (for a single subject - ``random effects'') and calculates the likelihood of the data given those random effect values. For most data sets, this process operates line-by-line: the log-likelihood is calculated for each observation and added. For example, we could compute the likelihood of a response time given a set of random effect values for a model. If the data are more likely given these random effect values are more likely (i.e. the model is closer to the data), the likelihood will be higher.

In the likelihood function, the parameter values must be assigned to the correct conditions and model parameters. For example, a linear regression model could have a slope and intercept parameter for easy and hard conditions i.e. four parameters. In this case, we would need to map the input parameter value for the slope in the easy condition onto the easy condition’s slope model parameter and then do the same for the hard slope and intercept parameters. This is much of the work of the log-likelihood function. Once mapped, we can use the appropriate values to calculate how likely were the data observed in each condition. Then we can calculate how likely the data are for the subject.

#### Writing a simple log-likelihood function
Let's write a simple log-likelihood function for a fabricated data set. You can copy the code below to follow along with our example.  
```{r setupllfab}
stim <- c("word", "word", "non-word", "word", "non-word", "non-word", "non-word", "word")
resp <- c("word", "word", "non-word", "word", "non-word", "non-word", "word", "non-word")
fab_data <- as.data.frame(cbind(stim, resp))
```
We create our dataset by combining a response `resp` and a stimulus `stim` vector into a data frame as shown in \@ref(tab:fakeHead) below.
```{r fakeHead, out.width='80%', fig.asp=.75, fig.align='center', echo=FALSE}
kable(fab_data, caption = 'A fabricated dataset of 8 trials with a response and a stimuls column')
```

Our log-likelihood function will step through the data, line by line, and find a likelihood value for each trial, under two parameters; d-prime `d` and criterion `C`. 

Here is our complete log-likelihood function. We have omitted some code from the code blocks below to enhance their appearance, so we encourage you to copy the log-likelihood function from the following code block if you'd like to follow along with our example. We'll now step through each component of the log-likelihood below.
```{r sdtLlComplete, attr.source = '.numberLines', eval=FALSE}
SDT_ll <- function(x, data, sample = FALSE){
  if (!sample) {
    out <- numeric(nrow(data))
    for (i in 1:nrow(data)) {
      if (stim[i] == "word") {
      if (resp[i] == "word") {
        out[i] <- pnorm(x["C"], mean = x["d"], sd = 1, 
                        log.p = TRUE, lower.tail = FALSE)
      } else {
        out[i] <- pnorm(x["C"], mean = x["d"], sd = 1, 
                        log.p = TRUE, lower.tail = TRUE)
      }
    } else {
      if (resp[i] == "word") {
        out[i] <- pnorm(x["C"], mean = 0, sd = 1, 
                        log.p = TRUE, lower.tail = FALSE)
      } else {
        out[i] <- pnorm(x["C"], mean = 0, sd = 1, 
                        log.p = TRUE, lower.tail = TRUE)
        }
      }
  }
  sum(out)
  }
}
```


We initialise the log-likelihood function with three arguments  
```{r llS1, attr.source = '.numberLines', eval=FALSE}
SDT_ll <- function(x, data, sample = FALSE) {
```
* `x` is a named parameter vector (e.g.`pars`)
* `data` is the dataset
* `sample =` sample values from the posterior distribution (For this simple example, we do not require a `sample` argument. )

The first if statement (line 2) checks if you want to sample, this is used for posterior predictive sampling which we will cover in later chapters. If you're not sampling (like us in this example), you need to create an output vector `out`. The `out` vector will contain the log-likelihood value for each row/trial in your dataset.
```{r sdtllL2, attr.source='.numberLines startFrom="2"', eval=FALSE}
  if (!sample) {
    data$response <- NA
    } else {
      out <- numeric(nrow(data))
      }
```

From line 9, we check each row in the data set, first considering all trials with <i>word</i> stimuli `if (stim[i] == "word"` (line 10), and assign a likelihood for responding <i>word</i> (line 12-13) or <i>non-word</i> (line 15-16). The <i>word</i> distribution has a mean of `x["d"]` (d-prime parameter) and a decision criterion parameter `x["C"]`. If the response is <i>word</i>, we are considering values ABOVE or to the right of <B>C</B> in figure \@ref(fig:SDT2), so we set `lower.tail =` to `FALSE`. If the response is <i>non-word</i>, we look for values BELOW or to the left of <B>C</B> in figure \@ref(fig:SDT2) and we set `lower.tail =` to `TRUE`. The `log.p =` argument takes the log of all likelihood values when set to `TRUE`. We do this so we can sum all likelihoods at the end of the log-likelihood function. 

```{r sdtllL8, attr.source='.numberLines startFrom="8"', eval=FALSE}
  if (!sample) {
    for (i in 1:nrow(data)) {
      if (stim[i] == "word") {
        if (resp[i] == "word") {
          out[i] <- pnorm(x["C"], mean = x["d"], sd = 1, 
                         log.p = TRUE, lower.tail = FALSE)
    } else {
      out[i] <- pnorm(x["C"], mean = x["d"], sd = 1, 
                     log.p = TRUE, lower.tail = TRUE)
      }
```

From the else statement on line 18, we have the function for <i>non-word</i> trials i.e. `stim[i] == "non-word"`. As can be seen below, the output value `out[i]` for these trials is arrived at in a similar manner to the <i>word</i> trials. We set the `mean` to 0 and the standard deviation `sd` to 1. If the response is <i>word</i>, we are considering values ABOVE or to the right of <B>C</B> in figure \@ref(fig:SDT2), so we set `lower.tail =` to `FALSE`. If the response is <i>non-word</i>, we look for values BELOW or to the left of <B>C</B> in figure \@ref(fig:SDT2) and we set `lower.tail =` to `TRUE`. Again we want the log of all likelihood values so we set `log.p = TRUE`.

```{r part4.3, attr.source='.numberLines startFrom="18"', eval=FALSE} 
else {
  if (resp[i] == "word") {
    out[i] <- pnorm(x["C"], mean = 0, sd = 1, 
                    log.p = TRUE, lower.tail = FALSE)
        } else {
          out[i] <- pnorm(x["C"], mean = 0, sd = 1, 
                         log.p = TRUE, lower.tail = TRUE)
        }
      }
```

The final line of code on line 24 sums the `out` vector and returns a log-likelihood value for your model.

```{r part4.4,eval=FALSE}
sum(out)
```

## Testing the SDT log-likelihood function

Before we run the log-likelihood function, we must create a parameter vector `pars` containing the same parameter names used in our log-likelihood function above i.e. we name the criterion `C` and d-prime parameter `d`. While we're testing the log-likelihood, we assign arbitrary values to each parameter. 

```{r, setupPars}
pars <- c(C = 0.8, d = 2)
```

We can test run our log-likelihood function by passing the parameter vector `pars` and the fabricated dataset we created above `fab_data`. 

```{r simple-SDT, include=FALSE}
SDT_ll <- function(x, data, sample = FALSE){
  if (sample) {
    data$response <- NA
  } else {
    out <- numeric(nrow(data))
  }
  if (!sample) {
  for (i in 1:nrow(data)) {
    if (stim[i] == "word") {
      if (resp[i] == "word") {
        out[i] <- pnorm(x["C"], mean = x["d"], sd = 1, 
                        log.p = TRUE, lower.tail = FALSE)
      } else {
        out[i] <- pnorm(x["C"], mean = x["d"], sd = 1, 
                        log.p = TRUE, lower.tail = TRUE)
      }
    } else {
      if (resp[i] == "word") {
        out[i] <- pnorm(x["C"], mean = 0, sd = 1, 
                        log.p = TRUE, lower.tail = FALSE)
      } else {
        out[i] <- pnorm(x["C"], mean = 0, sd = 1, 
                        log.p = TRUE, lower.tail = TRUE)
        }
      }
  }
  sum(out)
  }
}
```

```{r part5}
SDT_ll(pars, fab_data)
```
Now, if we change the parameter values, the log-likelihood value should also change.
```{r part6}
pars <- replace(pars, c(1,2), c(0.5, 1.2))
SDT_ll(pars, fab_data)
```
We can see the log-likelihood has changed. The second vector of parameter values are more likely than the first vector given the data.

## SDT log-likelihood function for Wagenmakers experiment {#sdtWag}

Now that we've covered a simple test example, let's create a log-likelihood function for the @wagenmakers2008diffusion dataset. 

### Description of Wagenmakers experiment

If you'd like to follow our example, you will need to download the dataset from this [link](https://www.ejwagenmakers.com/Code/2008/LexDecData.zip).The structure of the dataset will need to be modified in order to meet the requirements of the PMwG sampler. To do this, you can copy our [script](#wagSDTscript). You may attempt to modify the dataset yourself, but you must recreate the structure illustrated in table \@ref(tab:wagenmakers10).

Participants were asked to indicate whether a letter string was a <i>word</i> or a <i>non-word</i>.  A subset of Wagenmakers et al data are shown in table \@ref(tab:wagenmakers10), with each line representing a single trial. We have a `subject` column with a subject id (1-19), a condition column `cond` which indicates the proportion of <i>words</i> to <i>non-words</i> presented within a block of trials. In word blocks (`cond = w`) participants completed 75% word and 25% non-word trials and for non-word (`cond = nw`) blocks 75% non-word and 25% word trials. The `stim` column lists the word's frequency i.e. is the stimulus a <i>very low frequency</i> word (`stim = vlf`), a <i>low frequency</i> word (`stim = lf`), a <i>high frequency</i> word (`stim = hf`) or a <i>non-word</i> (`stim = nw`). The third column `resp` refers to the participant's response i.e. the participant responded <i>word</i> (`resp = W`) or <i>non-word</i> (`resp = NW`). The two remaining columns list the response time (`rt`) and whether the paricipant made a correct (`correct = 2`) or incorrect (`correct = 1`) choice. For more details about the experiment please see [the original paper](https://www.sciencedirect.com/science/article/pii/S0749596X07000496).


```{r setupWagen, include=FALSE}
load("dataObjects/wagenmakers2008.RData")
wgnmks2008 <- wagenmakers
```

```{r wagenmakers10, echo=FALSE, out.width='80%', fig.asp=.75, fig.align='center'}
kable(slice(wgnmks2008, 91:102), row.names = FALSE, caption = 'Subset of 12 trials from the Wagenmakers (2008) dataset.')
```

Our log-likelihood function for Wagenmakers experimental data is similar to the function we wrote above, except now we require a criterion parameter for each condition and a d-prime parameter for each of the `stim` <i>word</i> types. This is illustrated in figure \@ref(fig:SDT3) below, where we have a non-word criterion <B>C<sub>nw</sub></B>, a word criterion <B>C<sub>w</sub></B> and three distributions for each of the `stim` types with corresponding d-prime for each distribution: <b>d<sub>vlf</sub></b>, <b>d<sub>lf</sub></b>, <b>d<sub>hf</sub></b>.

```{r SDT3, echo=FALSE, out.width='100%', fig.show='hold', fig.cap='Signal detection theory example of lexical decision task'}
knitr::include_graphics('pngs/SDT_3.png')
```


Here is our complete log-likelihood function for the Wagenmakers data set.

```{r wagenSDT, attr.source='.numberLines startFrom="1"', eval=FALSE}
SDT_ll <- function(x, data, sample = FALSE){
  if (sample){
    data$response <- NA
  } else {
    out <- numeric(nrow(data))
  }
  if (!sample){
  for (i in 1:nrow(data)) {
    if (data$cond[i] == "w") {
    if (data$stim[i] == "hf") {
      if (data$resp[i] == "W") {
        out[i] <- pnorm(x["C.w"], mean = x["HF.d"], sd = 1,
                       log.p = TRUE, lower.tail = FALSE)
      } else {
        out[i] <- pnorm(x["C.w"], mean = x["HF.d"], sd = 1,
                       log.p = TRUE, lower.tail = TRUE)
      }
    } else if (data$stim[i] == "lf"){
      if (data$resp[i] == "W"){
        out[i] <- pnorm(x["C.w"], mean = x["LF.d"], sd = 1,
                       log.p = TRUE, lower.tail = FALSE)
      } else {
        out[i] <- pnorm(x["C.w"], mean = x["LF.d"], sd = 1,
                       log.p = TRUE, lower.tail = TRUE)
        }
      } else if (data$stim[i] == "vlf") {
        if (data$resp[i] == "W") {
          out[i] <- pnorm(x["C.w"], mean = x["VLF.d"], sd = 1,
                         log.p = TRUE, lower.tail = FALSE)
        } else {
          out[i] <- pnorm(x["C.w"], mean = x["VLF.d"], sd = 1,
                         log.p = TRUE, lower.tail = TRUE)
          }
        } else {
      if (data$resp[i] == "W") {
        out[i] <- pnorm(x["C.w"], mean = 0, sd = 1,
                       log.p = TRUE, lower.tail = FALSE)
      } else {
        out[i] <- pnorm(x["C.w"], mean = 0, sd = 1,
                       log.p = TRUE, lower.tail = TRUE)
        }
      }
    } else {
      if (data$stim[i] == "hf") {
        if (data$resp[i] == "W") {
          out[i] <- pnorm(x["C.nw"], mean = x["HF.d"], sd = 1, 
                         log.p = TRUE, lower.tail = FALSE)
        } else {
          out[i] <- pnorm(x["C.nw"], mean = x["HF.d"], sd = 1, 
                         log.p = TRUE, lower.tail = TRUE)
        }
      }  else if (data$stim[i] == "lf") {
        if (data$resp[i] == "W") {
          out[i] <- pnorm(x["C.nw"], mean = x["LF.d"], sd = 1, 
                         log.p = TRUE, lower.tail = FALSE)
        } else {
          out[i] <- pnorm(x["C.nw"], mean = x["LF.d"], sd = 1, 
                         log.p = TRUE, lower.tail = TRUE)
        }
      } else if (data$stim[i] == "vlf") {
        if (data$resp[i] == "W") {
          out[i] <- pnorm(x["C.nw"], mean = x["VLF.d"], sd = 1, 
                         log.p = TRUE, lower.tail = FALSE)
        } else {
          out[i] <- pnorm(x["C.nw"], mean = x["VLF.d"], sd = 1, 
                         log.p = TRUE, lower.tail = TRUE)
        }
      } else {
        if (data$resp[i] == "W") {
          out[i] <- pnorm(x["C.nw"], mean = 0, sd = 1, 
                         log.p = TRUE, lower.tail = FALSE)
        } else {
          out[i] <- pnorm(x["C.nw"], mean = 0, sd = 1, 
                         log.p = TRUE, lower.tail = TRUE)
        }
      }
    }
  }
  sum(out)
  }
}
```

Line 1 through to line 8 are the same as the log-likelihood we wrote for the fabricated dataset above. From line 9, we calculate the log-likelihood `out[i]` for <i>word</i> condition trials `cond[i] == "w"` when the stimulus is a high frequency word `stim[i] == "hf"` for each response. We do this by considering the upper tail of the high frequency word distribution `lower.tail = FALSE`, from the word criterion <B>C<sub>w</sub></B>, for <i>word</i> responses `resp[i] == "W"` and the lower tail for <i>non-word</i> responses (`else` statement on line 14). We then recycle this process for the remaining conditions/parameters in the experiment.

```{r wgnllSlow, attr.source='.numberLines startFrom="9"', eval=FALSE}
 if (data$cond[i] == "w") {
    if (data$stim[i] == "hf") {
      if (data$resp[i] == "W") {
        out[i] <- pnorm(x["C.w"], mean = x["HF.d"], sd = 1,
                       log.p = TRUE, lower.tail = FALSE)
      } else {
        out[i] <- pnorm(x["C.w"], mean = x["HF.d"], sd = 1,
                       log.p = TRUE, lower.tail = TRUE)
      }
```

This give us a log-likelihood for all data. Let's test this...

```{r sdt_freq, include=FALSE}
SDT_ll <- function(x, data, sample=FALSE){
  if (sample){
    data$response <- NA
  } else{
    out <- numeric(nrow(data))
  }
  if (!sample){
  for (i in 1:nrow(data)){
    if (data$cond[i] == "w"){
    if (data$stim[i] == "hf"){
      if (data$resp[i] == "W"){
        out[i] <- pnorm(x["C.w"], mean = x["HF.d"], sd = 1,
                       log.p = TRUE, lower.tail = FALSE)
      }else{
        out[i] <- pnorm(x["C.w"], mean = x["HF.d"], sd = 1,
                       log.p = TRUE, lower.tail = TRUE)
      }
    } else if (data$stim[i] == "lf"){
      if (data$resp[i] == "W"){
        out[i] <- pnorm(x["C.w"], mean = x["LF.d"], sd = 1,
                       log.p = TRUE, lower.tail = FALSE)
      }else{
        out[i] <- pnorm(x["C.w"], mean = x["LF.d"], sd = 1,
                       log.p = TRUE, lower.tail = TRUE)
        }
      } else if (data$stim[i] == "vlf"){
        if (data$resp[i] == "W"){
          out[i] <- pnorm(x["C.w"], mean = x["VLF.d"], sd = 1,
                         log.p = TRUE, lower.tail = FALSE)
        }else{
          out[i] <- pnorm(x["C.w"], mean = x["VLF.d"], sd = 1,
                         log.p = TRUE, lower.tail = TRUE)
          }
        }
    else{
      if (data$resp[i] == "W"){
        out[i] <- pnorm(x["C.w"], mean = 0, sd = 1,
                       log.p = TRUE, lower.tail = FALSE)
      }else{
        out[i] <- pnorm(x["C.w"], mean = 0, sd = 1,
                       log.p = TRUE, lower.tail = TRUE)
        }
      }
    }
    else{
      if (data$stim[i] == "hf"){
        if (data$resp[i] == "W"){
          out[i] <- pnorm(x["C.nw"], mean = x["HF.d"], sd = 1, 
                         log.p = TRUE, lower.tail = FALSE)
        }else{
          out[i] <- pnorm(x["C.nw"], mean = x["HF.d"], sd = 1, 
                         log.p = TRUE, lower.tail = TRUE)
        }
      }  else if (data$stim[i] == "lf"){
        if (data$resp[i] == "W"){
          out[i] <- pnorm(x["C.nw"], mean = x["LF.d"], sd = 1, 
                         log.p = TRUE, lower.tail = FALSE)
        }else{
          out[i] <- pnorm(x["C.nw"], mean = x["LF.d"], sd = 1, 
                         log.p = TRUE, lower.tail = TRUE)
        }
      } else if (data$stim[i] == "vlf"){
        if (data$resp[i] == "W"){
          out[i] <- pnorm(x["C.nw"], mean = x["VLF.d"], sd = 1, 
                         log.p = TRUE, lower.tail = FALSE)
        }else{
          out[i] <- pnorm(x["C.nw"], mean = x["VLF.d"], sd = 1, 
                         log.p = TRUE, lower.tail = TRUE)
        }
      }
      else{
        if (data$resp[i] == "W"){
          out[i] <- pnorm(x["C.nw"], mean = 0, sd = 1, 
                         log.p = TRUE, lower.tail = FALSE)
        }else{
          out[i] <- pnorm(x["C.nw"], mean = 0, sd = 1, 
                         log.p = TRUE, lower.tail = TRUE)
        }
      }
    }
  }
  sum(out)
  }
}
```

```{r part7.8, include=TRUE}
pars <- log(c(C.w = 1, C.nw = 0.5, HF.d = 3, LF.d = 1.8, VLF.d = 0.7))
SDT_ll(pars, wgnmks2008, sample = FALSE)
```


### Computation time of the log-likelihood function

You may have noticed that our log-likelihood function is slow and heavy on computer time when processing the data trial by trial. We recommend you write a 'slow' log-likelihood (as written above) to check it functions as it should before improving the function's efficiency.
<br>
Now we'll speed up our log-likelihood function. We have 16 possible values that could be assigned per line in the previous function (for the 16 cells of the design, given by proportion (2) x stimuli (4) x response (2)). Rather than looping over each trial, we could calculate the log-likelihood for each cell in the design and multiply the number of instances for each subject. To do this, we add a "<b>n</b>" column to the dataframe as shown in the code below.
```{r part8.1,include=TRUE}
wgnmks2008Fast <- as.data.frame(table(wgnmks2008$subject, wgnmks2008$cond,
                                  wgnmks2008$stim, wgnmks2008$resp))
names(wgnmks2008Fast) <- c("subject", "cond", "stim", "resp", "n")
```

Now our data frame looks like this..
```{r newdata, echo=FALSE}
kable(head(wgnmks2008Fast))
```


For our SDT log-likelihood function, we add a multiplying factor (`data$n[i]`) to calculate the model log-likelihood and rather than looping over trials.
```{r part8.2, eval=FALSE}
SDT_ll_fast <- function(x, data, sample = FALSE) {
  if (!sample) {
    out <- numeric(nrow(data))
    for (i in 1:nrow(data)) {
      if (data$cond[i] == "w") {
        if (data$stim[i] == "hf") {
          if (data$resp[i] == "W") {
            out[i] <- data$n[i] * pnorm(x["C.w"], mean = x["HF.d"],
                                     sd = 1, log.p = TRUE, lower.tail = FALSE)
          } else {
            out[i] <- data$n[i] * pnorm(x["C.w"], mean = x["HF.d"],
                                     sd = 1, log.p = TRUE, lower.tail = TRUE)
            }
          } else if (data$stim[i] == "lf") {
          if (data$resp[i] == "W") {
            out[i] <- data$n[i] * pnorm(x["C.w"], mean = x["LF.d"],
                                     sd = 1, log.p = TRUE, lower.tail = FALSE)
          } else {
            out[i] <- data$n[i] * pnorm(x["C.w"], mean = x["LF.d"],
                                     sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        } else if (data$stim[i] == "vlf") {
          if (data$resp[i] == "W") {
            out[i] <- data$n[i] * pnorm(x["C.w"], mean = x["VLF.d"],
                                     sd = 1, log.p = TRUE, lower.tail = FALSE)
          } else {
            out[i] <- data$n[i] * pnorm(x["C.w"], mean = x["VLF.d"],
                                     sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        } else {
          if (data$resp[i] == "W") {
            out[i] <- data$n[i] * pnorm(x["C.w"], mean = 0,
                                     sd = 1, log.p = TRUE, lower.tail = FALSE)
          } else {
            out[i] <- data$n[i] * pnorm(x["C.w"], mean = 0,
                                     sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        }
      }else{
        if (data$stim[i] == "hf") {
          if (data$resp[i] == "W") {
            out[i] <- data$n[i] * pnorm(x["C.nw"], mean = x["HF.d"],
                                     sd = 1, log.p = TRUE, lower.tail = FALSE)
          } else {
            out[i] <- data$n[i] * pnorm(x["C.nw"], mean = x["HF.d"],
                                     sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        }  else if (data$stim[i] == "lf"){
          if (data$resp[i] == "W") {
            out[i] <- data$n[i] * pnorm(x["C.nw"], mean = x["LF.d"],
                                     sd = 1, log.p = TRUE, lower.tail = FALSE)
          } else {
            out[i] <- data$n[i] * pnorm(x["C.nw"], mean = x["LF.d"],
                                     sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        } else if (data$stim[i] == "vlf") {
          if (data$resp[i] == "W") {
            out[i] <- data$n[i] * pnorm(x["C.nw"], mean = x["VLF.d"],
                                     sd = 1, log.p = TRUE, lower.tail = FALSE)
          } else {
            out[i] <- data$n[i] * pnorm(x["C.nw"], mean = x["VLF.d"],
                                     sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        } else {
          if (data$resp[i] == "W") {
            out[i] <- data$n[i] * pnorm(x["C.nw"], mean = 0,
                                     sd = 1, log.p = TRUE, lower.tail = FALSE)
          } else {
            out[i] <- data$n[i] * pnorm(x["C.nw"], mean = 0,
                                     sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        }
      }
    }
    sum(out)
  }
}
```

Now we have a fast(er) SDT log-likelihood function and we can compare its output with the slow log-likelihood function's output to make sure it is functioning correctly.

```{r fast_sdt,include=FALSE}
SDT_ll_fast <- function(x, data, sample = FALSE){
  #sets up a vector of outputs for when sample = false and erases the data$resp column when sample = true so that it can fill it in later
  if (sample){
    data$resp = NA
  } else{
    out <- numeric(nrow(data))
  }
  #in this example, each subject has only 1 line of data per condition (proportion of words condition (2) x stimulus (4) x response (2) = 16 lines per person )
  # and a value (n) representing the number of responses in that conditions 
  if (!sample){
    for (i in 1:nrow(data)){
      #in total, there are 16 calls to pnorm - which represent the 16 possible outcomes. Each will then only be called once per subject
      #for each line where the proportion was words do this
      if (data$cond[i] == "w"){
        #for each line where proportion was words and the stimulus was a hf word, do this
        if (data$stim[i] == "hf"){
          ##for each line where proportion was words the stimulus was a hf word and the response was "word", do this
          if (data$resp[i] == "W"){
            out[i]<- data$n[i]*pnorm(x["C.w"], mean = x["HF.d"], sd = 1, log.p = TRUE, lower.tail = FALSE)
          } else {
            out[i]<- data$n[i]*pnorm(x["C.w"], mean = x["HF.d"],sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        }  else if (data$stim[i] == "lf"){
          if (data$resp[i] == "W"){
            out[i]<- data$n[i]*pnorm(x["C.w"], mean = x["LF.d"],sd = 1, log.p = TRUE, lower.tail = FALSE)
          } else {
            out[i]<- data$n[i]*pnorm(x["C.w"], mean = x["LF.d"],sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        } else if (data$stim[i] == "vlf"){
          if (data$resp[i] == "W"){
            out[i]<- data$n[i]*pnorm(x["C.w"], mean = x["VLF.d"],sd = 1, log.p = TRUE, lower.tail = FALSE)
          } else {
            out[i]<- data$n[i]*pnorm(x["C.w"], mean = x["VLF.d"],sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        }
        else{
          if (data$resp[i] == "W"){
            out[i]<- data$n[i]*pnorm(x["C.w"], mean = 0,sd = 1, log.p = TRUE, lower.tail = FALSE)
          }else{
            out[i]<- data$n[i]*pnorm(x["C.w"], mean = 0,sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        }
      }
      else{
        if (data$stim[i] == "hf"){
          if (data$resp[i] == "W"){
            out[i]<- data$n[i]*pnorm(x["C.nw"], mean = x["HF.d"],sd = 1, log.p = TRUE, lower.tail = FALSE)
          }else{
            out[i]<- data$n[i]*pnorm(x["C.nw"], mean = x["HF.d"],sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        }  else if (data$stim[i] == "lf"){
          if (data$resp[i] == "W"){
            out[i]<- data$n[i]*pnorm(x["C.nw"], mean = x["LF.d"],sd = 1, log.p = TRUE, lower.tail = FALSE)
          }else{
            out[i]<- data$n[i]*pnorm(x["C.nw"], mean = x["LF.d"],sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        } else if (data$stim[i] == "vlf"){
          if (data$resp[i] == "W"){
            out[i]<- data$n[i]*pnorm(x["C.nw"], mean = x["VLF.d"],sd = 1, log.p = TRUE, lower.tail = FALSE)
          }else{
            out[i]<- data$n[i]*pnorm(x["C.nw"], mean = x["VLF.d"],sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        }
        else{
          if (data$resp[i] == "W"){
            out[i]<- data$n[i]*pnorm(x["C.nw"], mean = 0,sd = 1, log.p = TRUE, lower.tail = FALSE)
          }else{
            out[i]<- data$n[i]*pnorm(x["C.nw"], mean = 0,sd = 1, log.p = TRUE, lower.tail = TRUE)
          }
        }
      }
    }
    sum(out)
  }else{
    
    for (i in 1:nrow(data)){
      #for sampling - this could be done in a number of ways
      # in this example, the data is looked at line by line (so it must be in the original format) and takes a little longer
      #for this example, I first find the condition (non word or word proportion)
      if (data$cond[i]=="w"){
        #then i find the stimulus (hf,lf,vlf or nw)
        if (data$stim[i] == "hf"){
          #then for each stimulus i do a test using the criterion for that proportion condition (so this one is the word proportion so i use the C.w criterion)
          #using rnorm to pick a random value given a normal distribution with mean HF.d (given the stimulus condition)
          #i test that value against C.w
          #if the value is larger than C.w, the response is "word" otherwise, the simulated response is "non-word"
            data$resp[i]<-ifelse(test=(rnorm(1, mean = x["HF.d"],sd = 1))>x["C.w"], "word","non-word")
        } else if (data$stim[i] == "lf"){
            data$resp[i]<-ifelse(test=(rnorm(1, mean = x["LF.d"],sd = 1))>x["C.w"], "word","non-word")
           } else if (data$stim[i] == "vlf"){
            data$resp[i]<-ifelse(test=(rnorm(1, mean = x["VLF.d"],sd = 1))>x["C.w"], "word","non-word")
        } else {
            data$resp[i]<-ifelse(test=(rnorm(1, mean = 0,sd = 1)) >x["C.w"], "word","non-word")
          }
      } else {
        if (data$stim[i] == "hf"){
            data$resp[i]<-ifelse(test=(rnorm(1, mean = x["HF.d"],sd = 1))>x["C.nw"], "word","non-word")
        } else if (data$stim[i] == "lf"){
           data$resp[i]<-ifelse(test=(rnorm(1, mean = x["LF.d"],sd = 1))>x["C.nw"], "word","non-word")
        } else if (data$stim[i] == "vlf"){
            data$resp[i]<-ifelse(test=(rnorm(1, mean = x["VLF.d"],sd = 1))>x["C.nw"], "word","non-word")
        } else{
            data$resp[i]<-ifelse(test=(rnorm(1, mean = 0,sd = 1))>x["C.nw"], "word","non-word")
          }
        }
    }
    return(data)
    }
}
```
```{r part8.6, include=TRUE}
pars <- log(c(C.w = 1, C.nw = 0.5, HF.d = 3, LF.d = 1.8, VLF.d = 0.7))
SDT_ll(pars, wgnmks2008, sample = FALSE)
SDT_ll_fast(pars, wgnmks2008Fast, sample = FALSE)
```

Great—both functions produce the same log-likelihood! And we can run one final check by modifying the parameter vector's values and seeing if the log-likelihood value updates.

```{r part8.7,include=TRUE}
pars <- log(c(C.w = 1, C.nw = 0.8, HF.d = 2.7, LF.d = 1.8, VLF.d = 1.3))
SDT_ll(pars, wgnmks2008, sample = FALSE)
SDT_ll_fast(pars, wgnmks2008Fast, sample = FALSE)
```
As we saw with the fabricated dataset, the log-likelihood has changed. The second vector of parameter values are more likely than the first vector, given the data.
</br>
We recommend speeding up your code however you wish.  When you're confident that your log-likelihood functions correctly, you should save it as a separate script so it can be sourced and loaded when running the sampler.


## PMwG Framework {#sdtPMwG}

Now that we have written a log-likelihood function, we're ready to use the PMwG sampler package. 

Let's begin by loading the PMwG package.
```{r loadPMwGpkg}
library(pmwg)
```
Now we require the parameter vector `pars` we specified above and a priors object called `priors`. The `priors` object is a list that contains two components:



* `theta_mu_mean` a vector that is the prior for the mean of the group-level mean parameters
* `theta_mu_var` a covariance matrix that is the prior for the variance of the group-level mean parameters. In all examples we assume a diagonal matrix.




```{r part9.3, include=TRUE}
pars <- c("C.w", "C.nw", "HF.d", "LF.d", "VLF.d") 
# This is the same as the `pars` vector specified above

priors <- list(
  theta_mu_mean = rep(0, length(pars)),
  theta_mu_var = diag(rep(1, length(pars)))
)
```

The `priors` object in our example is initiated with zeros. An important thing to note is that to facilitate Gibbs sampling from the multivariate normal distribution for the group parameters, the random effects must be estimated on the real line. In our SDT example, the parameters are free to vary along the real line so no transformation of the random effects is required. We expand on this point in more detail in later examples where parameters are bounded and require transformation. The prior on the covariance matrix is hard-coded as the marginally non-informative prior of Huang and  Wand, as discussed in the [PMwG paper](https://www.sciencedirect.com/science/article/pii/S0022249620300389?casa_token=HPY1lTmXIRgAAAAA:aep1U95EwyrlrZ0kCuKQkbftCxgD5V9Hk_mkMBt4uTwVi177hBtLYGNjNcdLVeYj_-uTH0P8TwU).


The next step is to load your log-likelihood function/script.

```{r loadYaLL, echo=TRUE, eval=FALSE}
source(file = "yourLogLikelihoodFile.R")
```

Once you have set up your parameters, priors and written a log-likelihood function, the next step is to initialise the `sampler` object. 
```{r SDTsamplerObject, echo=TRUE, eval=FALSE}
sampler <- pmwgs(data = wgnmks2008Fast,
                 pars = pars,
                 prior = priors,
                 ll_func = SDT_ll_fast
                 )
```

The `pmwgs` function takes a set of arguments (listed below) and returns a list containing the required components for performing the particle metropolis within Gibbs steps.

* `data =`a data frame (e.g.`wgnmks2008Fast`) with a column for participants called <b>`subject`</b>
* `pars =` the model parameters to be used (e.g.`pars`)
* `prior =` the priors to be used (e.g.`priors`)
* `ll_func =` name of log-likelihood function you've sourced above (e.g.`SDT_ll_fast`)



### Model start points {#start-points}
You have the option to set model start points. We use 0 for the mean (`mu`) and a variance (`sig2`) of 0.01. If you chose not to specify start points, the sampler will randomly sample points from the prior distribution.
```{r part9.5, include=TRUE}
start_points <- list(mu = rep(0, length.out = length(pars)),
                     sig2 = diag(rep(.01, length(pars)))
)
```

The `start_points` object contains two vectors:

* `mu` a vector of start points for the mean the model parameters 
* `sig2` vector containing the start points of the covariance matrix of covariance between model parameters.


### Running the sampler {#run-sdtsampler}
Okay - now we are ready to run the sampler.  
```{r SDTrunSampler, echo=TRUE, eval=FALSE}
sampler <- init(sampler, 
                start_mu = start_points$mu,
                start_sig = start_points$sig2)
```
Here we are using the `init` function to generate initial start points for the random effects and storing them in the `sampler` object.  First we pass the `sampler` object from above that includes our data, parameters, priors and log-likelihood function.  If we decided to specify our own start points (as above), we would include the `start_mu` and `start_sig` arguments.


Now we can run the sampler using the `run_stage` function. The `run_stage` function takes four arguments:

* `x` the `sampler` object including parameters that was created from the init function above.
* `stage =` the sampling stage (e.g. `"burn"`, `"adapt"` or `"sample"`)
* `iter = ` is the number of iterations for the sampling stage. This is similar to running deMCMC, where it takes many iterations to reach the posterior space. Default = 1000.
* `particles =` is the number of particles generated on each iteration. Default = 1000.
* `display_progress =` shows progress bar for current stage
* `n_cores =` the number of cores to be used when running the sampler
* `epsilon = ` is a value between 0 and 1 which reduces the size of the sampling space. We use lower values of epsilon when there are more parameters to estimate. Default = 1.


It is optional to include the `iter =` and `particles =` arguments. If these are not included, `iter` and `particles` default to 1000. The number of iterations you choose for your burn-in stage is similar to choices made when running deMCMC; however, this varies depending on the time the model takes to reach the 'real' posterior space. 

First we run our burn-in stage by setting `stage =` to `"burn"`. 
```{r SDTburn, echo=TRUE, eval=FALSE}
burned <- run_stage(sampler, 
                    stage = "burn",
                    iter = 1000,
                    particles = 20,
                    display_progress = TRUE,
                    n_cores = 8)
```

Now we run our adaptation stage by setting `stage = "adapt"`. This function creates an efficient proposal distribution. The sampler will attempt to create the proposal distribution after 20 unique particles have been accepted for each subject. The sampler will then test whether the distribution was able to be created and if it was created, the sampler will move to the next stage otherwise the sampler will continue to sample. The number of iterations needs to be great enough to generate enough unique samples. The sampler will automatically exit the adapt stage when it has enough unique samples to create a multivariate normal ‘proposal’ distribution for each subject’s random effects. Thus we set iterations to a high number, as it should exit before reaching this point.
```{r SDTadaptation, echo=TRUE, eval=FALSE}
adapted <- run_stage(burned,
                     stage = "adapt",
                     iter = 1000,
                     particles = 20,
                     n_cores = 8)
```

At the start of the `sampled` stage, the sampler object will create a 'proposal' distribution for each subject's random effects using a conditional multi-variate normal. This proposal distribution is then used to efficiently generate new particles for each subject which means we can reduce the number of particles on each iteration whilst still achieving acceptance rates.
```{r SDTsampled, echo=TRUE, eval=FALSE}
sampled <- run_stage(adapted,
                     stage = "sample",
                     iter = 1000,
                     particles = 20,
                     n_cores = 8)
```


## Check the sampling process

It is a good idea to check your samples by producing some simple plots as shown below. The first plot gives an indication of the trace for the group level parameters. In this example, you will see the chains take only several iterations before arriving at the posterior; however, this may not always be the case. Each parameter trace (horizontal lines on plot \@ref(fig:parPlot)) should be stationary i.e. the trace should not trend up or down, and once the sampler reaches the posterior, the trace should remain relatively 'thin'. If the trace is wide and bounces between large values (e.g. between -3 and 3) then there may be an error in your log-likelihood function. 


As you can see in \@ref(fig:parPlot), the traces are clearly stable. Note that the number of iterations for the adaptation stage here is quite short because it's easy to estimate and so gets lots of unique draws. <b>Note:</b> The sampling stages (i.e. burn-in, adapatation and sampling) are demarcated by the black, vertical lines.

```{r load_data, include=FALSE}
load("dataObjects/SDT_sampled.Rdata")
```


```{r parPlot, echo=FALSE, out.width='100%', fig.show='hold', fig.cap='Posterior samples of parameters', warning=FALSE}
samps <- sampled$samples

stage.changes <- c(which(samps$stage == "adapt")[1], which(samps$stage == "sample")[1])

# ggplot trace plots
pltstrct <- as.data.frame(t(samps$theta_mu)) %>%
  rownames_to_column(var = "iteration") %>%
  pivot_longer(cols = !iteration)
pltstrct$iteration <- as.numeric(pltstrct$iteration)

trcPltSDT <- ggplot(pltstrct,
       aes(x = iteration, y=value, colour = name)) +
  geom_line() +
  theme_bw() +
  labs(y = "Parameter value",
       x = "Iteration") +
  theme(axis.title.y = element_text(size = 14,
                                    face = 'bold'),
        axis.text.y = element_text(size=14),
        axis.title.x = element_text(size = 14,
                                    face = 'bold'),
        axis.text.x = element_text(size=14),
        legend.position = "none") +
  geom_vline(xintercept = stage.changes)
trcPltSDT
```

The second plot below (figure \@ref(fig:subjLLPlot)) shows the likelihoods across iterations for each subject. Again we see that the likelihood values jump up after only a few iterations and then remain stable, with only slight movement. 


```{r subjLLPlot, echo=FALSE, out.width='100%', fig.show='hold', fig.cap='Posterior samples of subject log-likelihoods', warning=FALSE}
subjSamp <- sampled$samples

stage.changes <- c(which(subjSamp$stage == "adapt")[1], which(subjSamp$stage == "sample")[1])

# ggplot trace plots
pltstrct <- as.data.frame(t(subjSamp$subj_ll)) %>%
  rownames_to_column(var = "iteration") %>%
  pivot_longer(cols = !iteration)
pltstrct$iteration <- as.numeric(pltstrct$iteration)

subjTrcPltSDT <- ggplot(pltstrct,
       aes(x = iteration, y=value, colour = name)) +
  geom_line() +
  theme_bw() +
  labs(y = "Parameter value",
       x = "Iteration") +
  theme(axis.title.y = element_text(size = 14,
                                    face = 'bold'),
        axis.text.y = element_text(size=14),
        axis.title.x = element_text(size = 14,
                                    face = 'bold'),
        axis.text.x = element_text(size=14),
        legend.position = "none") +
  geom_vline(xintercept = stage.changes)
subjTrcPltSDT
```


## Simulating posterior data

Now we'll cover the sample operation within the fast log-likelihood function. We will use this on the full data set. The sample operation can be carried out in several ways (using rbinom etc). Please note that we do <b>NOT</b> recommend using this approach below and this should serve as an example only.

The `sample` process is similar to what we've covered above. We begin by assigning `NA`s to the response column to prepare it for simulated response data. We then consider a subset of the data, beginning with <i>word</i> condition and high-frequency `hf` word stimuli trials.

```{r part8.3, eval=FALSE}
  else{
    data$resp <- NA
   for (i in 1:nrow(data)){
      if (data$cond[i] == "w"){
        if (data$stim[i] == "hf"){
```
 
We then take the criterion for the <i>word</i> condition i.e. `C.w`. To simulate a response given our parameters we  use `rnorm` to pick a random value from a normal distribution with `mean = HF.d` (i.e. high frequency word stimulus) and a SD of 1 and we test that value against the <i>word</i> criterion `C.w`. If the value is larger than `C.w`, the simulated response will be <i>word</i> otherwise, the simulated response will be <i>non-word</i>.

```{r part8.4,eval=FALSE}
data$resp[i] <- ifelse(test = (rnorm(1, mean = x["HF.d"], 
                                     sd = 1)) > x["C.w"], "word", "non-word")
```

We repeat this process for each condition and stimulus combination as shown in the code block below.
```{r part8.5, eval=FALSE}
{ else if (data$stim[i] == "lf") {
  data$resp[i] <- ifelse(test = (rnorm(1, 
                                       mean = x["LF.d"], 
                                       sd = 1)) > x["C.w"], "word", "non-word")
  } else if (data$stim[i] == "vlf") {
    data$resp[i] <- ifelse(test = (rnorm(1, 
                                         mean = x["VLF.d"], 
                                         sd = 1)) > x["C.w"], "word", "non-word")
    } else {
      data$resp[i] <- ifelse(test = (rnorm(1, 
                                           mean = 0, 
                                           sd = 1)) > x["C.w"], "word", "non-word")
      }
} else {
  if (data$stim[i] == "hf") {
    data$resp[i] <- ifelse(test = (rnorm(1, 
                                         mean = x["HF.d"], 
                                         sd = 1)) > x["C.nw"], "word", "non-word")
    } else if (data$stim[i] == "lf") {
          data$resp[i] <- ifelse(test = (rnorm(1,
                                               mean = x["LF.d"], 
                                               sd = 1)) > x["C.nw"], "word", "non-word")
        } else if (data$stim[i] == "vlf") {
          data$resp[i] <- ifelse(test = (rnorm(1, 
                                               mean = x["VLF.d"], 
                                               sd = 1)) > x["C.nw"], "word", "non-word")
        } else {
          data$resp[i] <- ifelse(test = (rnorm(1, 
                                               mean = 0, 
                                               sd = 1)) > x["C.nw"], "word", "non-word")
          }
        }

```

Now we can run our simulation. Below is some code to achieve this.

```{r part 11, eval=FALSE}
n.posterior <- 20 # Number of samples from posterior distribution for each parameter.
pp.data <- list()
S <- unique(wgnmks2008$subject)
data <- split(x = wgnmks2008, 
              f = wgnmks2008$subject)
for (s in S) {
  cat(s," ")
  iterations = round(seq(from = 1051,
                         to = sampled$samples$idx,
                         length.out = n.posterior))
  for (i in 1:length(iterations)) {
    x <- sampled$samples$alpha[, s, iterations[i]]
    names(x) <- pars
    tmp <- SDT_ll_fast(x = x, 
                       data = wgnmks2008[wgnmks2008$subject == s,],
                       sample = TRUE)
    if (i == 1) {
      pp.data[[s]] <- cbind(i,tmp)
    } else {
      pp.data[[s]] <- rbind(pp.data[[s]], cbind(i, tmp))
    }
  }
}
```


And now we can plot samples against the data.
```{r part12graph, echo=FALSE, out.width='100%', fig.show='hold', fig.cap = "The proportion of 'word' responses within each cell of the design."}
ggplot(data = av.tmp,
       aes(x = cond, y = word_prop)) + 
  geom_col(alpha = 0.3) +
  geom_point(data = av.pp, aes(x = cond, y = word_prop)) + 
  theme_classic() + 
   labs(x = "Condition x stimulus",
       y = "Proportion of 'word'/n responses") +
  theme(axis.title.y = element_text(size = 12, face = 'bold'),
        axis.text.y = element_text(size=12),
        axis.title.x = element_text(size = 12, face = 'bold'),
        axis.text.x = element_text(size=12),
        legend.position = "none")
  
```

Figure \@ref(fig:part12graph) shows 20 posterior draws (dots) plotted against the data (bars). The posterior draws are for each individual subject - shown here is the average proportion of word responses. We can see that the model fits the data well.
